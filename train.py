# -*- coding: utf-8 -*-
"""
Created on Sun Jul 21 18:33:28 2019

@author: myidispg
"""

import pickle
import os
import torch

import numpy as np

from models.full_model import OpenPoseModel

import utilities.constants as constants
import utilities.helper as helper

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Read the pickle files into dictionaries.
pickle_in = open(os.path.join(constants.dataset_dir, 'keypoints_train_new.pickle'), 'rb')
keypoints_train = pickle.load(pickle_in)

pickle_in = open(os.path.join(constants.dataset_dir, 'keypoints_val_new.pickle'), 'rb')
keypoints_val = pickle.load(pickle_in)

pickle_in.close()

model = OpenPoseModel(num_joints = constants.num_joints, num_limbs=constants.num_limbs).to(device)

criterion_conf = torch.nn.MSELoss()
criterion_paf = torch.nn.MSELoss()

optimizer = torch.optim.Adam(model.parameters())

losses = []

count = 1
for images, conf_maps, pafs in helper.gen_data(keypoints_train, batch_size=2, val=True):
    
    # Convert all to PyTorch Tensors and move to the training device
    images = torch.from_numpy(images).view(2, 3, 224, 224).float().to(device)
    conf_maps = torch.from_numpy(conf_maps).float().to(device).view(2, constants.num_joints, 56, 56)
    pafs = torch.from_numpy(pafs).float().to(device).view(2, constants.num_limbs, 2, 56, 56)
    outputs = model(images)
    loss_conf_total = 0
    loss_paf_total = 0
    for i in range(1, 4): # There are 3 stages
        # Sums losses for all 3 stages.
        conf_out = outputs[i]['conf']
#        print(f'conf_out: {conf_out.shape}, conf_maps: {conf_maps.shape}')
        paf_out = outputs[i]['paf']
        paf_out = paf_out.reshape(
                paf_out.shape[0],
                paf_out.shape[1] // 2,
                2,
                paf_out.shape[2],
                paf_out.shape[3]
                )
#        print(f'paf_out: {paf_out.shape}, pafs: {pafs.shape}')
        loss_conf_total += criterion_conf(conf_out, conf_maps)
        loss_paf_total += criterion_paf(paf_out, pafs)
    loss = loss_conf_total + loss_paf_total
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
    losses.append(loss.item())
    print(f'count: {count}, loss: {loss.item()}')
#    print(f'images: {type(images)}, conf: {type(conf_maps)}, pafs: {type(pafs)}')
#    print(f'images: {images.shape}, conf: {conf_maps.shape}, pafs: {pafs.shape}')
#    print(f'outputs: {type(outputs)}')
#    if count == 100:
#        break
    count += 1
    
import matplotlib.pyplot as plt
plt.plot(list(range(len(losses))), losses)
plt.xlabel('Losses')
plt.ylabel('Epochs')

# Test an image
import cv2

img = cv2.imread(os.path.join(constants.dataset_dir, 'new_val2017', '000000000001.jpg'))
cv2.imshow('img', img)
cv2.waitKey()
cv2.destroyAllWindows()

img = img.reshape(1, -1, 224, 224)
outputs = model(torch.from_numpy(img).float().to(device))
conf = outputs[3]['conf'].cpu().detach().numpy().reshape(56, 56, -1)

def process_output_conf_map(image, scale_factor=4):
    """
    Returns the heatmap generated by model output is a visualizable form.
    Inputs:
        image: The heatmap generated by the model. Must be of shape:
            (batch, num_joints, im_width, im_height)
        scale_factor: The factor by which to enlarge the heatmap. Default=4
    """
    
    from utilities.helper import do_affine_transform
    
    print(image.shape)
    
    conf = np.zeros((image.shape[2], image.shape[3]))
    image = image.reshape(image.shape[2], image.shape[3], 17)
    for i in range(17):
        conf += image[:, :, i]
        
    conf = do_affine_transform(image, scale_factor)
    return conf

def visualize_output_conf_map(conf_map):
    """
    Visualizes a conf map using OpenCV.
    Inputs:
        conf_map: The conf_map to be visualized. Needs to be of the shape:
            (1, num_joints, width, height)
    """
    conf_map = process_output_conf_map(conf_map)
    cv2.imshow('COnfidence Map',conf_map)
    cv2.waitKey()
    cv2.destroyAllWindows()

visualize_output_conf_map(conf)
conf = process_output_conf_map(outputs[3]['conf'].cpu().detach().numpy())

disp = np.zeros((56, 56))
for i in range(17):
    disp += conf[:, :, i]

disp = helper.do_affine_transform(disp, 10)
    
cv2.imshow('disp', conf)
cv2.waitKey()
cv2.destroyAllWindows()